#!/usr/bin/env python3
"""
Visualize lifetime events from simulation log using Mermaid diagram.
"""
import re
import sys
from pathlib import Path


def parse_log(log_file):
    """Parse the log file and extract events."""
    events = []

    with open(log_file, "r") as f:
        for line in f:
            # Skip header and footer lines
            if "ready to go" in line or "finished" in line or "type       time" in line:
                continue

            # Parse event lines (both happened and generated)
            match = re.match(
                r"\s*(event:happ/|\s+\|-:gene/)\s+(\w+)\s+(\d+\.\d+)\s+(\d+\.\d+)\s+(\S+)\s+(\d+)",
                line,
            )
            if match:
                event_type = match.group(1).strip()
                event_name = match.group(2)
                time = float(match.group(3))
                duration = float(match.group(4))
                person = match.group(5)
                priority = int(match.group(6))

                is_happened = "event:happ" in event_type

                events.append(
                    {
                        "type": event_name,
                        "time": time,
                        "duration": duration,
                        "person": person,
                        "priority": priority,
                        "is_happened": is_happened,
                    }
                )

            # Parse update score lines
            match_score = re.match(r"event:happ/\s+(\d+):\s+(.+)", line)
            if match_score:
                events.append(
                    {
                        "type": "score",
                        "message": match_score.group(2),
                        "is_happened": True,
                    }
                )

    return events


def get_event_color(event_type):
    """Get color for different event types."""
    colors = {
        "endpr": "#90EE90",  # Light green
        "offnd": "#FFB6C6",  # Light pink
        "retrn": "#87CEEB",  # Light blue
        "leave": "#FFA500",  # Orange
        "score": "#FFFF99",  # Light yellow
    }
    return colors.get(event_type, "#E0E0E0")


def generate_mermaid(events, person_id=None):
    """Generate Mermaid diagram from events with timeline layout."""

    # Filter events by person if specified
    if person_id:
        events = [
            e
            for e in events
            if e.get("person") == person_id or e.get("type") == "score"
        ]

    # Remove score events
    events = [e for e in events if e["type"] != "score"]

    # Identify which generated events actually happened
    generated_events_map = {}  # time+type -> gen_index
    happened_events_map = {}  # time+type -> happened_index

    for i, event in enumerate(events):
        key = (event["time"], event["type"])
        if not event["is_happened"]:
            generated_events_map[key] = i
        else:
            happened_events_map[key] = i

    # Identify canceled events
    canceled_events = set()
    for key, gen_idx in generated_events_map.items():
        if key not in happened_events_map:
            canceled_events.add(gen_idx)

    # Build generation and cancellation relationships
    generation_map = {}  # generated_idx -> generating_idx
    cancellation_map = {}  # canceled_idx -> canceling_idx

    # First pass: identify what generated each event
    for i, event in enumerate(events):
        if event["is_happened"]:
            # Find all events generated by this one
            j = i + 1
            while j < len(events) and not events[j]["is_happened"]:
                generation_map[j] = i
                j += 1

    # Second pass: for canceled events, find what canceled them
    for gen_idx in canceled_events:
        gen_event = events[gen_idx]
        gen_time = gen_event["time"]
        generating_idx = generation_map.get(gen_idx)

        # Find which happened event after generation actually canceled it
        # For leave events, look for the last retrn before gen_time
        # For other events, look for the last offnd/retrn before gen_time
        canceling_idx = None
        if generating_idx is not None:
            for i in range(generating_idx + 1, len(events)):
                if events[i]["is_happened"] and events[i]["time"] < gen_time:
                    # This event happens before the generated event's scheduled time
                    if gen_event["type"] == "leave":
                        # Leave events are canceled by retrn events
                        if events[i]["type"] == "retrn":
                            canceling_idx = i  # Keep updating to get the LAST retrn
                    else:
                        # Other events canceled by offnd or retrn
                        if events[i]["type"] in ["offnd", "retrn"]:
                            canceling_idx = i  # Keep updating to get the LAST one

        if canceling_idx is not None:
            cancellation_map[gen_idx] = canceling_idx

    # Create a unified node map: (time, type) -> node_id
    event_key_to_node = {}  # (time, type) -> node_id
    node_map = {}  # event index -> node_id
    happened_indices = []  # Track happened event indices in order

    # Use top-down layout
    mermaid_lines = ["graph TD"]
    mermaid_lines.append("    Start([Start<br/>T=0])")

    # Create nodes - prefer generated nodes, upgrade them to happened if they occur
    for i, event in enumerate(events):
        time = event["time"]
        event_type = event["type"]
        key = (time, event_type)

        if event["is_happened"]:
            happened_indices.append(i)

            # Check if this event was already generated
            if key in event_key_to_node:
                # Reuse the generated node
                node_map[i] = event_key_to_node[key]
            else:
                # Create new node for happened event
                node_id = f"N{i}"
                node_map[i] = node_id
                event_key_to_node[key] = node_id

                label = f"{event_type}<br/>T={time:.0f}"
                if event_type == "leave":
                    mermaid_lines.append(f"    {node_id}([{label}])")  # Stadium
                else:
                    mermaid_lines.append(f"    {node_id}[{label}]")  # Box
        else:
            # Generated event
            if key not in event_key_to_node:
                node_id = f"N{i}"
                node_map[i] = node_id
                event_key_to_node[key] = node_id

                label = f"{event_type}<br/>T={time:.0f}"
                if i in canceled_events:
                    label += "<br/>âŒ"
                    mermaid_lines.append(f"    {node_id}{{{{'{label}'}}}}")  # Diamond
                else:
                    mermaid_lines.append(f"    {node_id}[/{label}/]")  # Parallelogram
            else:
                # This generated event has the same key as an existing node
                node_map[i] = event_key_to_node[key]

    # Create main timeline (happened events)
    prev_happened = "Start"
    for idx in happened_indices:
        node_id = node_map[idx]
        mermaid_lines.append(f"    {prev_happened} ==> {node_id}")
        prev_happened = node_id

    # Add generation arrows
    # First, identify which happened events have no generation record
    # These should be shown as generated from Start
    happened_without_generation = set()
    for i in happened_indices:
        event = events[i]
        key = (event["time"], event["type"])
        # If this happened event was never generated (not in generated_events_map), it's initial
        if key not in generated_events_map:
            happened_without_generation.add(i)

    # Add arrows from Start to initial events (both generated-only and happened-without-generation)
    if happened_indices:
        first_happened_idx = happened_indices[0]
        # Generated events before first happened event
        for i in range(first_happened_idx):
            if not events[i]["is_happened"] and i in node_map:
                mermaid_lines.append(f"    Start -.-> {node_map[i]}")

        # Happened events with no generation record (initial events)
        for i in happened_without_generation:
            mermaid_lines.append(f"    Start -.-> {node_map[i]}")

    for i, event in enumerate(events):
        if not event["is_happened"]:
            continue

        # Find all events generated by this one
        generated_by_this = []
        j = i + 1
        while j < len(events) and not events[j]["is_happened"]:
            generated_by_this.append(j)
            j += 1

        # Add arrows to generated events
        for gen_idx in generated_by_this:
            mermaid_lines.append(f"    {node_map[i]} -.-> {node_map[gen_idx]}")

    # Add special arrows for canceled leave events showing their origin
    for canceled_idx in canceled_events:
        if events[canceled_idx]["type"] == "leave":
            generating_idx = generation_map.get(canceled_idx)
            if generating_idx is not None:
                # Show where this leave was generated from
                mermaid_lines.append(
                    f"    {node_map[generating_idx]} -.ğŸ”´ gen leave .-> {node_map[canceled_idx]}"
                )

    # Add cancellation arrows (only return canceling leave)
    for canceled_idx, canceling_idx in cancellation_map.items():
        if (
            events[canceled_idx]["type"] == "leave"
            and events[canceling_idx]["type"] == "retrn"
        ):
            mermaid_lines.append(
                f"    {node_map[canceling_idx]} -. âŒ cancels .-> {node_map[canceled_idx]}"
            )

    # Add styling - collect unique nodes and determine their status
    mermaid_lines.append("")
    colors = get_event_color

    styled_nodes = set()

    for i, event in enumerate(events):
        node_id = node_map[i]
        if node_id in styled_nodes:
            continue  # Already styled this node
        styled_nodes.add(node_id)

        color = colors(event["type"])

        # Determine if this node represents a happened event
        # Check if any happened event uses this node
        is_happened = any(
            node_map[j] == node_id and events[j]["is_happened"]
            for j in range(len(events))
        )

        # Check if any canceled event uses this node
        is_canceled = any(
            node_map[j] == node_id and j in canceled_events for j in range(len(events))
        )

        if is_happened:
            mermaid_lines.append(
                f"    style {node_id} fill:{color},stroke:#333,stroke-width:3px"
            )
        elif is_canceled:
            mermaid_lines.append(
                f"    style {node_id} fill:#FFD0D0,stroke:#FF0000,stroke-width:3px"
            )
        else:
            mermaid_lines.append(
                f"    style {node_id} fill:#F0F0F0,stroke:#999,stroke-width:2px,stroke-dasharray: 5 5"
            )

    return "\n".join(mermaid_lines)


def generate_html(mermaid_code, person_id=None):
    """Generate HTML file with embedded Mermaid diagram."""
    title = (
        f"Lifetime Visualization - Person {person_id}"
        if person_id
        else "Lifetime Visualization"
    )

    html_template = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }}
        .legend {{
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
            border-radius: 4px;
        }}
        .legend h3 {{
            margin-top: 0;
            color: #333;
        }}
        .legend ul {{
            margin: 10px 0;
            padding-left: 20px;
        }}
        .legend li {{
            margin: 5px 0;
        }}
        .mermaid-container {{
            width: 100%;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            padding: 20px;
        }}
        .mermaid {{
            display: inline-block;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>{title}</h1>
        
        <div class="mermaid-container">
            <div class="mermaid">
{mermaid_code}
            </div>
        </div>
        
        <div class="legend">
            <h3>Legend</h3>
            <h4>Timeline (Top to Bottom)</h4>
            <ul>
                <li><strong>Thick arrows (==>):</strong> Main timeline - events that happened</li>
                <li><strong>Dashed arrows (-.->):</strong> Generated/scheduled events</li>
                <li><strong>ğŸ”´ gen leave arrows:</strong> Shows which event generated a canceled leave</li>
                <li><strong>âŒ cancels arrows:</strong> Return events that cancel leave events</li>
            </ul>
            <h4>Node Shapes & Colors</h4>
            <ul>
                <li><strong>Rectangle [Box]:</strong> Happened events (thick border)</li>
                <li><strong>Stadium ([Box]):</strong> Leave system events</li>
                <li><strong>Parallelogram [/Box/]:</strong> Generated events (not yet happened)</li>
                <li><strong>Diamond {{Box}}:</strong> Canceled events with âŒ</li>
            </ul>
            <h4>Event Type Colors</h4>
            <ul>
                <li><strong>ğŸŸ¢ Green:</strong> End probation (endpr)</li>
                <li><strong>ğŸ©· Pink:</strong> Offense (offnd)</li>
                <li><strong>ğŸ”µ Blue:</strong> Return (retrn)</li>
                <li><strong>ğŸŸ  Orange:</strong> Leave system (leave)</li>
                <li><strong>âšª Light Gray:</strong> Generated pending events</li>
                <li><strong>ğŸ”´ Red:</strong> Canceled events</li>
            </ul>
        </div>
    </div>
    
    <script>
        mermaid.initialize({{ startOnLoad: true, theme: 'default' }});
    </script>
</body>
</html>
"""
    return html_template


def main():
    if len(sys.argv) < 2:
        print("Usage: python visualize_log.py <log_file> [person_id] [-o output.html]")
        sys.exit(1)

    log_file = sys.argv[1]
    person_id = None
    output_file = None

    # Parse arguments
    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == "-o" and i + 1 < len(sys.argv):
            output_file = sys.argv[i + 1]
            i += 2
        else:
            person_id = sys.argv[i]
            i += 1

    if not Path(log_file).exists():
        print(f"Error: File '{log_file}' not found")
        sys.exit(1)

    events = parse_log(log_file)

    if not events:
        print("No events found in log file")
        sys.exit(1)

    mermaid_code = generate_mermaid(events, person_id)

    # If output file specified, save as HTML
    if output_file:
        html_content = generate_html(mermaid_code, person_id)
        with open(output_file, "w") as f:
            f.write(html_content)
        print(f"âœ“ Saved visualization to {output_file}")
        print(f"  Open the file in your browser to view the diagram.")
    else:
        # Print to console in markdown format
        print("```mermaid")
        print(mermaid_code)
        print("```")
        print()
        print("\n**Legend:**")
        print("Timeline (Top to Bottom):")
        print("  - Thick arrows (==>): Main timeline - events that happened")
        print("  - Dashed arrows (-.->): Generated/scheduled events")
        print("  - ğŸ”´ gen leave arrows: Shows which event generated a canceled leave")
        print("  - âŒ cancels arrows: Event that directly cancels another")
        print("\nNode Shapes & Colors:")
        print("  - Rectangle [Box]: Happened events (thick border)")
        print("  - Stadium ([Box]): Leave system events")
        print("  - Parallelogram [/Box/]: Generated events (not yet happened)")
        print("  - Diamond {{Box}}: Canceled events with âŒ")
        print("\nEvent Type Colors:")
        print("  - ğŸŸ¢ Green: End probation (endpr)")
        print("  - ğŸ©· Pink: Offense (offnd)")
        print("  - ğŸ”µ Blue: Return (retrn)")
        print("  - ğŸŸ  Orange: Leave system (leave)")
        print("  - âšª Light Gray: Generated pending events")
        print("  - ğŸ”´ Red: Canceled events")


if __name__ == "__main__":
    main()
